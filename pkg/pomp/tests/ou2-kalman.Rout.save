
R version 3.2.0 (2015-04-16) -- "Full of Ingredients"
Copyright (C) 2015 The R Foundation for Statistical Computing
Platform: x86_64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library(pomp)
> 
> set.seed(577639485L)
> 
> kalman.filter <- function (y, x0, a, b, sigma, tau) {
+   n <- nrow(y)
+   ntimes <- ncol(y)
+   sigma.sq <- sigma%*%t(sigma)
+   tau.sq <- tau%*%t(tau)
+   inv.tau.sq <- solve(tau.sq)
+   cond.dev <- numeric(ntimes)
+   filter.mean <- matrix(0,n,ntimes)
+   pred.mean <- matrix(0,n,ntimes)
+   pred.var <- array(0,dim=c(n,n,ntimes))
+   dev <- 0
+   m <- x0
+   v <- diag(0,n)
+   for (k in seq(length=ntimes)) {
+     pred.mean[,k] <- M <- a%*%m
+     pred.var[,,k] <- V <- a%*%v%*%t(a)+sigma.sq
+     q <- b%*%V%*%t(b)+tau.sq
+     r <- y[,k]-b%*%M
+     cond.dev[k] <- n*log(2*pi)+log(det(q))+t(r)%*%solve(q,r)
+     dev <- dev+cond.dev[k]
+     q <- t(b)%*%inv.tau.sq%*%b+solve(V)
+     v <- solve(q)
+     filter.mean[,k] <- m <- v%*%(t(b)%*%inv.tau.sq%*%y[,k]+solve(V,M))
+   }
+   list(
+        pred.mean=pred.mean,
+        pred.var=pred.var,
+        filter.mean=filter.mean,
+        cond.loglik=-0.5*cond.dev,
+        loglik=-0.5*dev
+        )
+ }
> 
> kalman <- function (x, object, params) {
+   y <- obs(object)
+   p <- params
+   p[names(x)] <- x
+   x0 <- init.state(object,params=p)
+   a <- matrix(p[c('alpha.1','alpha.2','alpha.3','alpha.4')],2,2)
+   b <- diag(1,2)
+   sigma <- matrix(p[c('sigma.1','sigma.2','sigma.2','sigma.3')],2,2)
+   sigma[1,2] <- 0
+   tau <- diag(p['tau'],2,2)
+   -kalman.filter(y,x0,a,b,sigma,tau)$loglik
+ }
> 
> pompExample(ou2)
newly created object(s):
 ou2 
> 
> # true coefficients
> p.truth <- coef(ou2)
> cat("coefficients at `truth'\n")
coefficients at `truth'
> print(p.truth[c('alpha.1','alpha.4','x1.0','x2.0')],digits=4)
alpha.1 alpha.4    x1.0    x2.0 
    0.8     0.9    -3.0     4.0 
> cat("Kalman filter log likelihood at truth\n")
Kalman filter log likelihood at truth
> print(loglik.truth <- -kalman(p.truth,ou2,p.truth),digits=4)
[1] -479
> 
> # make a wild guess
> p.guess <- p.truth[c('alpha.1','alpha.4','x1.0','x2.0')]*exp(rnorm(n=4,mean=0,sd=0.5))
> cat("coefficients at guess\n")
coefficients at guess
> print(p.guess,digits=4)
alpha.1 alpha.4    x1.0    x2.0 
 0.4237  0.6210 -4.9309  4.2186 
> cat("Kalman filter log likelihood at guess\n")
Kalman filter log likelihood at guess
> print(loglik.guess <- -kalman(p.guess,ou2,p.truth),digits=4)
[1] -511.8
> 
> # find MLE using Kalman filter starting at the guess
> cat("running Kalman filter estimation\n")
running Kalman filter estimation
> tic <- Sys.time()
> kalm.fit1 <- optim(p.guess,kalman,object=ou2,params=p.truth,hessian=T,control=list(trace=2))
  Nelder-Mead direct search function minimizer
function value for initial parameters = 511.775815
  Scaled convergence tolerance is 7.62605e-06
Stepsize computed as 0.493088
BUILD              5 511.844749 505.360856
REFLECTION         7 511.780782 477.413329
LO-REDUCTION       9 511.775815 477.413329
LO-REDUCTION      11 507.796383 477.413329
HI-REDUCTION      13 505.360856 477.413329
HI-REDUCTION      15 485.552686 477.413329
LO-REDUCTION      17 484.509022 477.413329
HI-REDUCTION      19 480.951298 477.413329
HI-REDUCTION      21 478.596539 477.413329
HI-REDUCTION      23 478.560567 477.413329
HI-REDUCTION      25 478.123899 477.413329
HI-REDUCTION      27 477.679801 477.413329
HI-REDUCTION      29 477.675116 477.413329
HI-REDUCTION      31 477.607881 477.413329
HI-REDUCTION      33 477.554058 477.413329
HI-REDUCTION      35 477.474282 477.413329
REFLECTION        37 477.457729 477.391603
LO-REDUCTION      39 477.443980 477.391603
HI-REDUCTION      41 477.442964 477.391603
REFLECTION        43 477.413329 477.363559
HI-REDUCTION      45 477.401362 477.363559
EXTENSION         47 477.400089 477.311957
LO-REDUCTION      49 477.391603 477.311957
LO-REDUCTION      51 477.380266 477.311957
REFLECTION        53 477.363559 477.308763
EXTENSION         55 477.343298 477.276752
LO-REDUCTION      57 477.337915 477.276752
REFLECTION        59 477.311957 477.264470
REFLECTION        61 477.308763 477.256650
LO-REDUCTION      63 477.289753 477.256650
LO-REDUCTION      65 477.276752 477.256650
EXTENSION         67 477.269605 477.244453
REFLECTION        69 477.264470 477.243984
LO-REDUCTION      71 477.260609 477.243984
HI-REDUCTION      73 477.256650 477.243984
REFLECTION        75 477.248262 477.243357
LO-REDUCTION      77 477.245648 477.243282
REFLECTION        79 477.244453 477.241804
LO-REDUCTION      81 477.243984 477.241440
HI-REDUCTION      83 477.243357 477.241378
HI-REDUCTION      85 477.243282 477.241378
LO-REDUCTION      87 477.241804 477.241378
REFLECTION        89 477.241742 477.241190
HI-REDUCTION      91 477.241702 477.241186
HI-REDUCTION      93 477.241440 477.241186
LO-REDUCTION      95 477.241378 477.241114
HI-REDUCTION      97 477.241209 477.241114
HI-REDUCTION      99 477.241190 477.241073
LO-REDUCTION     101 477.241186 477.241059
HI-REDUCTION     103 477.241123 477.241059
HI-REDUCTION     105 477.241114 477.241057
HI-REDUCTION     107 477.241073 477.241051
HI-REDUCTION     109 477.241063 477.241047
HI-REDUCTION     111 477.241059 477.241045
HI-REDUCTION     113 477.241057 477.241042
HI-REDUCTION     115 477.241051 477.241042
Exiting from Nelder Mead minimizer
    117 function evaluations used
> toc <- Sys.time()
> print(toc-tic)
Time difference of 2.517805 secs
> tic <- Sys.time()
> print(loglik.mle <- -kalm.fit1$value,digits=4)
[1] -477.2
> 
> cat("summary of results\n")
summary of results
> print(
+       cbind(
+             truth=c(p.truth[names(kalm.fit1$par)],loglik=loglik.truth),
+             MLE=c(kalm.fit1$par,loglik=loglik.mle),
+             SE=c(sqrt(diag(solve(kalm.fit1$hessian))),NA)
+             ),
+       digits=3
+       )
         truth      MLE     SE
alpha.1    0.8    0.685 0.0676
alpha.4    0.9    0.879 0.0358
x1.0      -3.0   -3.996 3.9811
x2.0       4.0    2.952 2.6278
loglik  -479.0 -477.241     NA
> 
> proc.time()
   user  system elapsed 
  3.032   0.044   3.077 
